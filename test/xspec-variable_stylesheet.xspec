<?xml version="1.0" encoding="UTF-8"?>
<x:description
	xmlns:my="http://example.org/ns/my"
	xmlns:myv="http://example.org/ns/my/variable"
	xmlns:t="http://www.jenitennison.com/xslt/xspec"
	xmlns:x="http://www.jenitennison.com/xslt/xspec"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	stylesheet="xspec-variable-tested.xsl">
	<!-- Variables used only in this test file are in a dedicated namespace to prevent conflict with
	 global parameters or global variables in the file to be tested. -->

	<!--XQuery needs mode=test:generate-variable-declarations fix.
	 TODO: When that's available, move "Combination of @select and element content" scenario to the
	 "Variables can be defined in different ways." scenario in xspec-variable.xspec. -->
	<x:scenario label="Code that temporarily does not work in XQuery but does work in XSLT">
		<x:scenario label="Combination of @select and element content">
			<x:variable name="myv:select-and-content" select="//bar">
				<foo><bar>text</bar></foo>
			</x:variable>
			<x:call function="exactly-one">
				<x:param select="$myv:select-and-content"/>
			</x:call>
			<x:expect label="uses the selection from the x:variable element's content as the variable value.">
				<bar>text</bar>
			</x:expect>
		</x:scenario>
	</x:scenario>

	<!-- Scenarios specific to XSLT -->

	<x:scenario label="Variables can appear in different parts of scenario.">
		<!-- For tests using function call scenarios, see xspec-variable.xspec. -->
		<x:scenario label="x:variable interspersed with x:context, x:call[@template], and x:expect">
			<x:variable name="myv:before_context" select="'before_context'"/>
			<x:context><mycontext role="{$myv:before_context}"/></x:context>
			<x:variable name="myv:after_context" select="'after_context'"/>
			<x:call template="context-mirror-template"/>
			<x:variable name="myv:after_call" select="'after_call'"/>
			<x:expect label="reflects expected behavior of named template for this context,">
				<mycontext role="before_context"/>
			</x:expect>
			<x:variable name="myv:after_expect" select="'after_expect'"/>
			<x:expect label="and expected value for each variable."
				test="($myv:before_context='before_context') and
				($myv:after_context='after_context') and
				($myv:after_call='after_call') and
				($myv:after_expect='after_expect')"
			/>
		</x:scenario>
		<x:scenario label="x:variable interspersed with x:context and x:expect">
			<x:variable name="myv:before_context" select="'before_context'"/>
			<x:context><mycontext role="{$myv:before_context}"/></x:context>
			<x:variable name="myv:after_context" select="'after_context'"/>
			<x:expect label="reflects expected behavior of template rule for this context,">
				<mycontext role="before_context"/>
			</x:expect>
			<x:variable name="myv:after_expect" select="'after_expect'"/>
			<x:expect label="and expected value for each variable."
				test="($myv:before_context='before_context') and
				($myv:after_context='after_context') and
				($myv:after_expect='after_expect')"
			/>
		</x:scenario>
		<x:scenario label="x:variable interspersed with x:context[x:param] and x:expect">
			<x:variable name="myv:before_context" select="'before_context'"/>
			<x:context mode="param-mirror-mode">
				<x:param name="param-items" select="$myv:before_context"/>
				<mycontext/>
			</x:context>
			<x:variable name="myv:after_context" select="'after_context'"/>
			<x:expect label="reflects expected behavior of template rule for this parameter,"
				select="'before_context'"/>
			<x:variable name="myv:after_expect" select="'after_expect'"/>
			<x:expect label="and expected value for each variable."
				test="($myv:before_context='before_context') and
				($myv:after_context='after_context') and
				($myv:after_expect='after_expect')"
			/>
		</x:scenario>
		<x:scenario label="x:variable used to store the context">
			<x:variable name="myv:context"><foo/></x:variable>
			<x:context select="$myv:context"/>
			<x:expect label="reflects expected behavior of template rule for this context."><foo/></x:expect>
		</x:scenario>
	</x:scenario>

	<!-- Should this scenario be moved to test/xspec-prefix-conflict_stylesheet.xspec after that is on master branch? -->
	<t:scenario label="Test that x: is available for use by end users (i.e., not hard-coded in tools)">
		<t:variable name="x:elementx" as="element()" xmlns:x="x-urn:test:xspec-prefix-conflict">
			<x:foo/>
		</t:variable>
		<t:context select="$x:elementx" xmlns:x="x-urn:test:xspec-prefix-conflict"/>
		<t:expect label="the result"><x:foo xmlns:x="x-urn:test:xspec-prefix-conflict"/></t:expect>
	</t:scenario>

</x:description>
