<?xml version="1.0" encoding="UTF-8"?>
<t:description xmlns:t="http://www.jenitennison.com/xslt/xspec"
               xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
               stylesheet="../src/compiler/compile-xproc-tests.xsl">

   <!-- Default $measure-time depends on global context item. Set it false here. -->
   <t:param name="measure-time" select="false()" />

   <t:scenario label="x:scenario[@label] transformed in x:compile-scenario template">
      <t:context href="compile-xproc-tests/compile-scenario.xspec" select="//t:scenario" />
      <t:call template="t:compile-scenario">
         <t:param name="call" as="empty-sequence()" tunnel="yes" />
         <t:param name="context" as="empty-sequence()" tunnel="yes" />
         <t:param name="reason-for-pending" as="empty-sequence()" />
         <t:param name="run-sut-now" select="false()" />
      </t:call>
      <t:expect>
         <t:label>
            - is xsl:template
            - @name is Q{XSpec-namespace}scenario-ID
            - the scenario label xsl:message
            - the constructor (xsl:element) of the x:scenario element
            - the constructor (xsl:element) of the x:scenario/x:label element
         </t:label>
         <xsl:template name="Q{{http://www.jenitennison.com/xslt/xspec}}dummy-scenario-id"
                       as="element(Q{{http://www.jenitennison.com/xslt/xspec}}scenario)">
            <xsl:context-item use="absent" />
            <xsl:message>my scenario label</xsl:message>
            <xsl:element name="scenario"
                         namespace="http://www.jenitennison.com/xslt/xspec">
               <xsl:attribute name="id"
                              namespace="">dummy-scenario-id</xsl:attribute>
               <xsl:attribute name="xspec"
                              namespace="" />
               <xsl:element name="label"
                            namespace="http://www.jenitennison.com/xslt/xspec">
                  <xsl:text>my scenario label</xsl:text>
               </xsl:element>
               <xsl:element name="input-wrap"
                  namespace="">...</xsl:element>
            </xsl:element>
         </xsl:template>
      </t:expect>
   </t:scenario>

   <!--
       <t:expect/>
       
       TODO: Track down how it is transformed (named template, rule
       in a mode, etc.) and test it explicitly...
   -->
   <t:scenario label="x:expect[@test] transformed in x:compile-expect template">
      <t:context href="compile-xproc-tests/compile-expect.xspec" select="//t:expect" />
      <t:call template="t:compile-expect">
         <t:param name="call" as="empty-sequence()" tunnel="yes" />
         <t:param name="context" as="empty-sequence()" tunnel="yes" />
         <t:param name="reason-for-pending" as="empty-sequence()" />
         <t:param name="param-uqnames" as="empty-sequence()" />
      </t:call>
      <t:expect label="is a template"
                test="$t:result instance of element(xsl:template)"/>
      <t:expect label="@test must be transformed to xsl:sequence/@select"
                test="$t:result/xsl:variable[@name eq 'Q{urn:x-xspec:compile:impl}test-result']">
         <xsl:variable name="Q{{urn:x-xspec:compile:impl}}test-result"
                       as="item()*">
            <xsl:choose>
               <xsl:when test="$Q{{urn:x-xspec:compile:impl}}result-type-mismatch">
                  <!--In case of data type mismatch, do not process @test-->
               </xsl:when>
               <xsl:when test="count($Q{{urn:x-xspec:compile:impl}}test-items) eq 1">
                  <xsl:for-each select="$Q{{urn:x-xspec:compile:impl}}test-items">
                     <xsl:sequence select="false()"
                                   version="3" />
                  </xsl:for-each>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:sequence select="false()"
                                version="3" />
               </xsl:otherwise>
            </xsl:choose>
         </xsl:variable>
      </t:expect>
      <t:expect label="@result-type must be transformed to result-type-mismatch variable"
         test="$t:result/xsl:variable[@name eq 'Q{urn:x-xspec:compile:impl}result-type-mismatch']">
         <xsl:variable name="Q{{urn:x-xspec:compile:impl}}result-type-mismatch"
            as="Q{{http://www.w3.org/2001/XMLSchema}}boolean"
            select="not($Q{{http://www.jenitennison.com/xslt/xspec}}result instance of item())" />
      </t:expect>
      <t:scenario label="XProc-specific additions:">
         <t:expect label="@port must be transformed to xsl:variable that modifies $x:result"
            test="$t:result/xsl:variable[@name eq 'Q{http://www.jenitennison.com/xslt/xspec}result']">
            <xsl:variable name="Q{{http://www.jenitennison.com/xslt/xspec}}result"
               as="item()*"
               select="$Q{{http://www.jenitennison.com/xslt/xspec}}result?xproc-result"/>
         </t:expect>
         <t:expect label="with error checking that @port is a valid key of $x:result"
            test="$t:result/xsl:variable[@name eq 'Q{http://www.jenitennison.com/xslt/xspec}result']/preceding-sibling::*[1]">
            <xsl:if xmlns:map="http://www.w3.org/2005/xpath-functions/map"
               test="not('xproc-result' = map:keys($Q{{http://www.jenitennison.com/xslt/xspec}}result))">
               <xsl:message terminate="yes">...</xsl:message>
            </xsl:if>
         </t:expect>
      </t:scenario>
   </t:scenario>

   <t:scenario label="x:option elements transformed in option-map-text template">
      <t:context href="compile-xproc-tests/compile-scenario.xspec" select="//t:call"/>
      <t:call template="option-map-text">
         <t:param name="parent-scenario" select="$t:context/parent::t:scenario"/>
      </t:call>
      <t:expect label="is a text node" test="$t:result instance of text()"/>
      <t:expect label="describing a map of options, using URI-qualified names"
         test="matches($t:result, concat(
            'map\{',
            '''Q\{x-urn:test:compile-xproc-tests\}option1'': \$Q\{urn:x-xspec:compile:impl\}option-[0-9a-f]+, ',
            '''Q\{x-urn:test:compile-xproc-tests\}option2'': \$Q\{urn:x-xspec:compile:impl\}option-[0-9a-f]+',
            '\}'
         ))"/>
   </t:scenario>
</t:description>