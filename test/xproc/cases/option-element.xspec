<?xml version="1.0" encoding="UTF-8"?>
<x:description xmlns:items="x-urn:test:xspec-items" xmlns:mirror="x-urn:test:mirror"
    xmlns:x="http://www.jenitennison.com/xslt/xspec" xproc="library-mirror.xpl">
    <x:helper stylesheet="../../items.xsl"/>

    <!-- For scenarios that use options with names in a namespace, see
        no-input-two-options-one-output.xspec -->

    <x:scenario label="x:option can specify a value using">
        <x:scenario label="embedded child nodes">
            <x:call step="mirror:option-value">
                <x:option name="opt"><document/></x:option>
            </x:call>
            <x:like label="verify result document"/>
        </x:scenario>
        <x:scenario label="embedded child nodes and @select">
            <x:call step="mirror:option-value">
                <x:option name="opt" select="//document">
                    <root>
                        <document/>
                    </root>
                </x:option>
            </x:call>
            <x:like label="verify result document"/>
        </x:scenario>
        <x:scenario label="@href pointing to an XML document">
            <x:call step="mirror:option-value">
                <x:option name="opt" href="document.xml"/>
            </x:call>
            <x:like label="verify result document"/>
        </x:scenario>
        <x:scenario label="@href pointing to a JSON document (specific to XProc testing)">
            <x:scenario label="Verify content">
                <x:call step="mirror:option-value">
                    <x:option name="opt" href="document-object.json"/>
                </x:call>
                <x:expect label="from the file" port="xproc-result"
                    select="map{ 'key1': 'val1', 'key2': 2 }"/>
            </x:scenario>
            <x:scenario label="Verify content type">
                <x:call step="mirror:option-property">
                    <x:option name="property-to-get" select="'content-type'"/>
                    <x:option name="opt" href="document-object.json"/>
                </x:call>
                <x:expect label="application/json" port="xproc-result"
                    test="$x:document-properties?(QName('', 'content-type'))"
                    select="'application/json'"/>
            </x:scenario>
            <x:scenario label="Verify base URI">
                <x:call step="mirror:option-property">
                    <x:option name="property-to-get" select="'base-uri'"/>
                    <x:option name="opt" href="document-object.json"/>
                </x:call>
                <x:expect port="xproc-result" test="substring-after(., 'test/xproc/cases/')"
                    select="'document-object.json'">
                    <x:label>reflects the document, not .xsl or .xpl intermediate file</x:label>
                </x:expect>
            </x:scenario>
        </x:scenario>
        <x:scenario label="@href pointing to a non-XML HTML document (specific to XProc testing)">
            <x:scenario label="Verify content">
                <x:call step="mirror:option-value">
                    <x:option name="opt" href="document-not-xhtml.html"/>
                </x:call>
                <x:expect label="from the file" port="xproc-result">
                    <html xmlns="http://www.w3.org/1999/xhtml">...</html>
                </x:expect>
            </x:scenario>
            <x:scenario label="Verify content type">
                <x:call step="mirror:option-property">
                    <x:option name="property-to-get" select="'content-type'"/>
                    <x:option name="opt" href="document-not-xhtml.html"/>
                </x:call>
                <x:expect label="text/html" port="xproc-result" select="'text/html'"/>
            </x:scenario>
            <x:scenario label="Verify base URI">
                <x:call step="mirror:option-property">
                    <x:option name="property-to-get" select="'base-uri'"/>
                    <x:option name="opt" href="document-not-xhtml.html"/>
                </x:call>
                <x:expect port="xproc-result" test="substring-after(., 'test/xproc/cases/')"
                    select="'document-not-xhtml.html'">
                    <x:label>reflects the document, not .xsl or .xpl intermediate file</x:label>
                </x:expect>
            </x:scenario>
        </x:scenario>
        <x:scenario label="@href and @select">
            <x:call step="mirror:option-value">
                <x:option name="opt" href="document.xml" select="root()"/>
            </x:call>
            <x:like label="verify result document"/>
        </x:scenario>
        <x:scenario label="@select alone">
            <x:call step="mirror:option-value">
                <x:option name="opt" select="parse-xml('&lt;document/>')"/>
            </x:call>
            <x:like label="verify result document"/>
        </x:scenario>
    </x:scenario>
    <x:scenario label="When opt is not provided in x:call">
        <x:call step="mirror:option-value"/>
        <x:expect label="the option-value step returns the option's default value"
            port="xproc-result" select="'default'"/>
    </x:scenario>
    <x:scenario label="When opt is a sequence of nodes other than attribute and namespace nodes">
        <x:call step="mirror:option-value">
            <x:option name="opt" select="$items:wrappable-nodes"/>
        </x:call>
        <x:expect port="xproc-result" result-type="document-node()+" test="count($x:result)"
            select="count($items:wrappable-nodes)">
            <x:label>the option-value step returns a sequence of document nodes, one for each item
                in the original sequence</x:label>
        </x:expect>
        <x:expect label="the comment node matches" port="xproc-result"
            test="$x:result/comment()" select="$items:wrappable-nodes[self::comment()]"/>
        <x:expect port="xproc-result"
            test="$x:result/element()" select="(
            $items:wrappable-nodes[self::document-node(element())]/element(),
            $items:wrappable-nodes[self::element()]
            )">
            <x:label>the element nodes match (the original element became wrapped in a document
                node)</x:label>
        </x:expect>
        <x:expect port="xproc-result" test="$x:result/text()"
            select="(
            $items:wrappable-nodes[self::document-node()]/text(),
            $items:wrappable-nodes[self::text()]
            )">
            <x:label>the two text nodes match (the original text node became wrapped in a document
                node)</x:label>
        </x:expect>
        <x:expect label="the PI node matches" port="xproc-result"
            test="$x:result/processing-instruction()"
            select="$items:wrappable-nodes[self::processing-instruction()]"/>
    </x:scenario>
    <x:scenario label="When x:option has multiple child nodes">
        <x:call step="mirror:option-value">
            <x:option name="opt">
                <node1/>
                <!-- node2 -->
                <node3/>
                <?node4?>
                <x:text>node 5</x:text>
            </x:option>
        </x:call>
        <x:expect port="xproc-result" result-type="document-node()+" test="count($x:result)"
            select="5">
            <x:label>the option-value step returns a sequence of document nodes, one for each item
                in the original sequence.</x:label>
        </x:expect>
        <x:expect port="xproc-result">
            <x:label>x:expect[@port][not(@test)][not(@select)] with multiple child nodes
                automatically wraps each node in a document node. The sequence of document nodes
                is the expected result.</x:label>
            <node1/>
            <!-- node2 -->
            <node3/>
            <?node4?>
            <x:text>node 5</x:text>
        </x:expect>
        <x:expect port="xproc-result" test="$x:document-properties?(QName('', 'content-type'))"
            select="(
            'application/xml',
            'application/xml',
            'application/xml',
            'application/xml',
            'text/plain'
            )">
            <x:label>The content type is application/xml, except that the text node is text/plain</x:label>
        </x:expect>
    </x:scenario>
    <x:scenario label="When x:option has multiple child nodes and also has select='/'">
        <x:call step="mirror:option-value">
            <x:option name="opt" select="/">
                <node1/>
                <!-- node2 -->
                <node3/>
                <?node4?>
                <x:text>node 5</x:text>
            </x:option>
        </x:call>
        <x:expect port="xproc-result" result-type="document-node()" test="count($x:result)"
            select="1">
            <x:label>the option-value step returns one document node.</x:label>
        </x:expect>
        <x:expect port="xproc-result"
            label="x:expect[@port][not(@test)] can use select='/' to wrap all the children"
            select="/">
            <node1/>
            <!-- node2 -->
            <node3/>
            <?node4?>
            <x:text>node 5</x:text>
        </x:expect>
    </x:scenario>
    <x:scenario label="When x:option[@select] selects multiple nodes, even at different tree levels">
        <x:call step="mirror:option-value">
            <x:option name="opt" select="//descendant">
                <level1>
                    <level2>
                        <descendant level="2"/>
                        <level3>
                            <descendant level="3"/>
                        </level3>
                    </level2>
                </level1>
            </x:option>
        </x:call>
        <x:expect port="xproc-result" result-type="document-node()+" test="count($x:result)"
            select="2">
            <x:label>the option-value step returns a sequence of document nodes, one for each item
                in the original sequence.</x:label>
        </x:expect>
        <x:expect port="xproc-result" select="//descendant">
            <x:label>x:expect[@port][not(@test)][@select] in the same format automatically wraps
                each selected node in a document node. The sequence of document nodes is the
                expected result.</x:label>
            <level1>
                <level2>
                    <descendant level="2"/>
                    <level3>
                        <descendant level="3"/>
                    </level3>
                </level2>
            </level1>
        </x:expect>
        <x:expect label="Confirm the result without using @select" port="xproc-result">
            <descendant level="2"/>
            <descendant level="3"/>
        </x:expect>
    </x:scenario>
    <x:scenario label="When opt is a number">
        <x:call step="mirror:option-value">
            <x:option name="opt" select="1"/>
        </x:call>
        <x:like label="verify JSON content type for one item"/>
        <x:expect label="the result is the number" port="xproc-result" select="1"/>
    </x:scenario>
    <x:scenario label="When opt is an array">
        <x:call step="mirror:option-value">
            <x:option name="opt" select="[1, 2]"/>
        </x:call>
        <x:like label="verify JSON content type for one item"/>
        <x:expect label="the result is the array" port="xproc-result" select="[1, 2]"/>
    </x:scenario>
    <x:scenario label="When opt is a map">
        <x:call step="mirror:option-value">
            <x:option name="opt" select="map{1: 2}"/>
        </x:call>
        <x:like label="verify JSON content type for one item"/>
        <x:expect label="the result is the map" port="xproc-result" select="map{1: 2}"/>
    </x:scenario>
    <x:scenario label="When opt is a string (which gets converted to application/json)">
        <x:call step="mirror:option-value">
            <x:option name="opt" select="'one'"/>
        </x:call>
        <x:like label="verify JSON content type for one item"/>
        <x:expect label="the result is the string" port="xproc-result" select="'one'"/>
    </x:scenario>
    <x:scenario label="If an option name duplicates an XSpec variable name">
        <x:call step="mirror:option-value">
            <x:option name="opt"><xproc-option/></x:option>
        </x:call>
        <x:variable name="opt"><xspec-variable/></x:variable>
        <x:expect label="there is no conflict; the option has its value" port="xproc-result">
            <xproc-option/>
        </x:expect>
        <x:expect label="and the variable has its own value" test="$opt">
            <xspec-variable/>
        </x:expect>
    </x:scenario>
    <x:scenario label="If an option name is literally 'name'">
        <x:call step="mirror:option-named-name">
            <x:option name="name" select="'option-value'"/>
        </x:call>
        <x:expect label="the result is the value from x:option" port="xproc-result"
            select="'option-value'"/>
    </x:scenario>

    <x:scenario shared="yes" label="verify result document">
        <x:expect label="and the option-value step returns the value" port="xproc-result">
            <document/>
        </x:expect>
    </x:scenario>
    <x:scenario shared="yes" label="verify JSON content type for one item">
        <x:expect label="the content type is application/json" port="xproc-result"
            test="$x:document-properties?(QName('', 'content-type'))"
            select="'application/json'"/>
    </x:scenario>
</x:description>
