<?xml version="1.0" encoding="UTF-8"?>
<x:description xmlns:h="http://www.w3.org/1999/xhtml" xmlns:mirror="x-urn:test:mirror"
    xmlns:s="x-urn:test:xproc:steplibrary"
    xmlns:thd="http://www.jenitennison.com/xslt/xspec/helper/document-nodes"
    xmlns:x="http://www.jenitennison.com/xslt/xspec" xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xproc="library-content-types.xpl">

    <x:helper xproc="../../../tutorial/helper/document-nodes/test-helper-load.xpl"
        stylesheet="../../../tutorial/helper/document-nodes/test-helper-load.xsl"/>

    <!-- This scenario demonstrates loading an HTML file using XPath functions, but when the
        input port needs only external files, the following alternatives that get evaluated
        in XProc (not XSLT/XPath) are simpler:
        
        <x:input port="source" href="document.html"/>

        <x:input port="source">
            <p:document href="document.html"/>
        </x:input>
        
        Related tests: for @href pointing to non-XML file, see input-element.xspec;
        for p:document children of x:input, see p-document-within-x-input.xspec.
    -->
    <x:scenario label="Description from XHTML document">
        <x:call step="s:get-html-description">
            <x:input port="source" href="document-xhtml.html"/>
        </x:call>
        <x:like label="verify returned element"/>
    </x:scenario>
    <x:scenario label="Description from HTML non-XML document">
        <x:scenario label="using thd:load-via-xproc()">
            <x:call step="s:get-html-description">
                <x:input port="source" select="thd:load-via-xproc('document-not-xhtml.html', $x:xspec-uri)"/>
                <!-- Note: Don't use <x:input> with both href and select attributes, for
                    a non-well-formed HTML document (e.g., meta element missing end tag).
                    Also, the step being called expects HTML elements to be in the
                    http://www.w3.org/1999/xhtml namespace. -->
            </x:call>
            <x:like label="verify returned element"/>
        </x:scenario>
        <x:pending>
            <x:label>Requires xslt-version="4.0" and html-doc function</x:label>
            <x:scenario label="using html-doc function">
                <x:variable name="html" as="document-node()"
                    select="'document-not-xhtml.html' => resolve-uri($x:xspec-uri) => html-doc()"/>
                <x:call step="s:get-html-description">
                    <x:input port="source" select="$html"/>
                </x:call>
                <x:like label="verify returned element"/>
            </x:scenario>
        </x:pending>
    </x:scenario>

    <x:scenario label="Document properties">
        <x:scenario label="of XHTML input file">
            <x:variable name="href" select="'document-xhtml.html'"/>
            <x:like label="check document properties"/>
        </x:scenario>
        <x:scenario label="of HTML non-XML input file">
            <x:variable name="href" select="'document-not-xhtml.html'"/>
            <x:like label="check document properties"/>
        </x:scenario>
    </x:scenario>

    <!-- Shared scenarios -->
    <x:scenario shared="yes" label="verify returned element">
        <x:expect label="is a meta element" port="xproc-result">
            <h:meta name="description" content="Description"/>
        </x:expect>
    </x:scenario>
    <x:scenario shared="yes" label="check document properties">
        <x:call step="mirror:identity">
            <x:input port="source" select="thd:load-via-xproc($href, $x:xspec-uri)"/>
        </x:call>
        <x:expect label="are content type 'application/xml'" port="xproc-result"
            test="$x:document-properties?(QName('', 'content-type'))"
            select="'application/xml'"/>
        <x:expect label="and the base URI of an HTML file (not .xsl or .xpl intermediate file)"
            port="xproc-result"
            test="$x:document-properties?(QName('', 'base-uri')) ! replace(., '^.*-xhtml', '')"
            select="'.html'"/>
    </x:scenario>

</x:description>
